{"ast":null,"code":"/*!\r\n  * Bootstrap selector-engine.js v5.3.3 (https://getbootstrap.com/)\r\n  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\r\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n  */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('../util/index.js')) : typeof define === 'function' && define.amd ? define(['../util/index'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.SelectorEngine = factory(global.Index));\n})(this, function (index_js) {\n  'use strict';\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap dom/selector-engine.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  const getSelector = element => {\n    let selector = element.getAttribute('data-bs-target');\n    if (!selector || selector === '#') {\n      let hrefAttribute = element.getAttribute('href');\n\n      // The only valid content that could double as a selector are IDs or classes,\n      // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n      // `document.querySelector` will rightfully complain it is invalid.\n      // See https://github.com/twbs/bootstrap/issues/32273\n      if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {\n        return null;\n      }\n\n      // Just in case some CMS puts out a full URL with the anchor appended\n      if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {\n        hrefAttribute = \"#\".concat(hrefAttribute.split('#')[1]);\n      }\n      selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;\n    }\n    return selector ? selector.split(',').map(sel => index_js.parseSelector(sel)).join(',') : null;\n  };\n  const SelectorEngine = {\n    find(selector) {\n      let element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;\n      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\n    },\n    findOne(selector) {\n      let element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;\n      return Element.prototype.querySelector.call(element, selector);\n    },\n    children(element, selector) {\n      return [].concat(...element.children).filter(child => child.matches(selector));\n    },\n    parents(element, selector) {\n      const parents = [];\n      let ancestor = element.parentNode.closest(selector);\n      while (ancestor) {\n        parents.push(ancestor);\n        ancestor = ancestor.parentNode.closest(selector);\n      }\n      return parents;\n    },\n    prev(element, selector) {\n      let previous = element.previousElementSibling;\n      while (previous) {\n        if (previous.matches(selector)) {\n          return [previous];\n        }\n        previous = previous.previousElementSibling;\n      }\n      return [];\n    },\n    // TODO: this is now unused; remove later along with prev()\n    next(element, selector) {\n      let next = element.nextElementSibling;\n      while (next) {\n        if (next.matches(selector)) {\n          return [next];\n        }\n        next = next.nextElementSibling;\n      }\n      return [];\n    },\n    focusableChildren(element) {\n      const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable=\"true\"]'].map(selector => \"\".concat(selector, \":not([tabindex^=\\\"-\\\"])\")).join(',');\n      return this.find(focusables, element).filter(el => !index_js.isDisabled(el) && index_js.isVisible(el));\n    },\n    getSelectorFromElement(element) {\n      const selector = getSelector(element);\n      if (selector) {\n        return SelectorEngine.findOne(selector) ? selector : null;\n      }\n      return null;\n    },\n    getElementFromSelector(element) {\n      const selector = getSelector(element);\n      return selector ? SelectorEngine.findOne(selector) : null;\n    },\n    getMultipleElementsFromSelector(element) {\n      const selector = getSelector(element);\n      return selector ? SelectorEngine.find(selector) : [];\n    }\n  };\n  return SelectorEngine;\n});","map":{"version":3,"names":["getSelector","element","selector","getAttribute","hrefAttribute","includes","startsWith","concat","split","trim","map","sel","index_js","parseSelector","join","SelectorEngine","find","arguments","length","undefined","document","documentElement","Element","prototype","querySelectorAll","call","findOne","querySelector","children","filter","child","matches","parents","ancestor","parentNode","closest","push","prev","previous","previousElementSibling","next","nextElementSibling","focusableChildren","focusables","el","isDisabled","isVisible","getSelectorFromElement","getElementFromSelector","getMultipleElementsFromSelector"],"sources":["C:\\Github\\rushikersclub-web\\frontend\\node_modules\\bootstrap\\js\\src\\dom\\selector-engine.js"],"sourcesContent":["/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/selector-engine.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nimport { isDisabled, isVisible, parseSelector } from '../util/index.js'\n\nconst getSelector = element => {\n  let selector = element.getAttribute('data-bs-target')\n\n  if (!selector || selector === '#') {\n    let hrefAttribute = element.getAttribute('href')\n\n    // The only valid content that could double as a selector are IDs or classes,\n    // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n    // `document.querySelector` will rightfully complain it is invalid.\n    // See https://github.com/twbs/bootstrap/issues/32273\n    if (!hrefAttribute || (!hrefAttribute.includes('#') && !hrefAttribute.startsWith('.'))) {\n      return null\n    }\n\n    // Just in case some CMS puts out a full URL with the anchor appended\n    if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {\n      hrefAttribute = `#${hrefAttribute.split('#')[1]}`\n    }\n\n    selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null\n  }\n\n  return selector ? selector.split(',').map(sel => parseSelector(sel)).join(',') : null\n}\n\nconst SelectorEngine = {\n  find(selector, element = document.documentElement) {\n    return [].concat(...Element.prototype.querySelectorAll.call(element, selector))\n  },\n\n  findOne(selector, element = document.documentElement) {\n    return Element.prototype.querySelector.call(element, selector)\n  },\n\n  children(element, selector) {\n    return [].concat(...element.children).filter(child => child.matches(selector))\n  },\n\n  parents(element, selector) {\n    const parents = []\n    let ancestor = element.parentNode.closest(selector)\n\n    while (ancestor) {\n      parents.push(ancestor)\n      ancestor = ancestor.parentNode.closest(selector)\n    }\n\n    return parents\n  },\n\n  prev(element, selector) {\n    let previous = element.previousElementSibling\n\n    while (previous) {\n      if (previous.matches(selector)) {\n        return [previous]\n      }\n\n      previous = previous.previousElementSibling\n    }\n\n    return []\n  },\n  // TODO: this is now unused; remove later along with prev()\n  next(element, selector) {\n    let next = element.nextElementSibling\n\n    while (next) {\n      if (next.matches(selector)) {\n        return [next]\n      }\n\n      next = next.nextElementSibling\n    }\n\n    return []\n  },\n\n  focusableChildren(element) {\n    const focusables = [\n      'a',\n      'button',\n      'input',\n      'textarea',\n      'select',\n      'details',\n      '[tabindex]',\n      '[contenteditable=\"true\"]'\n    ].map(selector => `${selector}:not([tabindex^=\"-\"])`).join(',')\n\n    return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el))\n  },\n\n  getSelectorFromElement(element) {\n    const selector = getSelector(element)\n\n    if (selector) {\n      return SelectorEngine.findOne(selector) ? selector : null\n    }\n\n    return null\n  },\n\n  getElementFromSelector(element) {\n    const selector = getSelector(element)\n\n    return selector ? SelectorEngine.findOne(selector) : null\n  },\n\n  getMultipleElementsFromSelector(element) {\n    const selector = getSelector(element)\n\n    return selector ? SelectorEngine.find(selector) : []\n  }\n}\n\nexport default SelectorEngine\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}